import moderngl
import numpy as np
from PIL import Image
import os
import gc

class ShaderRenderer:
    def __init__(self, width=512, height=512):
        self.width = width
        self.height = height
        self.ctx = None
        
        # --- ROBUST CONTEXT CREATION ---
        # Try EGL first as it is essential for Colab and headless environments.
        try:
            self.ctx = moderngl.create_context(standalone=True, backend='egl')
        except Exception as e:
            # Fallback to standard context for local machine development.
            try:
                self.ctx = moderngl.create_context(standalone=True)
            except Exception as e2:
                raise Exception(f"Failed to create ModernGL Context: {e} | {e2}")
        
        # OPTIMIZATION: Static Geometry (Screen Quad).
        # We create this once and reuse it for every render call.
        vertices = np.array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0], dtype='f4')
        self.vbo = self.ctx.buffer(vertices.tobytes())
        
        # OPTIMIZATION: Static Framebuffer.
        # Created once, then cleared and reused to save memory.
        self.fbo = self.ctx.simple_framebuffer((self.width, self.height), components=3)
        
        # Standard Vertex Shader for a pass-through quad.
        self.vert_shader = '''
        #version 330
        in vec2 in_vert;
        out vec2 uv;
        void main() {
            uv = in_vert;
            gl_Position = vec4(in_vert, 0.0, 1.0);
        }
        '''
        
        # Load the Common GLSL Library from the project root.
        self.common_lib = ""
        try:
            # If gl_renderer.py is in /lib, the project root is one level up.
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(current_dir)
            common_path = os.path.join(project_root, 'common.glsl') 
            
            # Explicit fallback for Google Colab environments.
            if not os.path.exists(common_path):
                 common_path = '/content/drive/MyDrive/projects/EarthShader/common.glsl'

            if os.path.exists(common_path):
                with open(common_path, 'r') as f:
                    self.common_lib = f.read()
            else:
                print(f"Warning: common.glsl not found at {common_path}.")
                
        except NameError:
            # Handle cases where __file__ is not defined in Jupyter.
            pass

    def render(self, fragment_code, output_path):
        # Inject the common library and the sample code into the GLSL template.
        full_frag_shader = f'''
        #version 330
        uniform vec2 iResolution;
        out vec4 fragColor;
        
        {self.common_lib}
        
        {fragment_code}
        
        void main() {{
            vec4 color;
            mainImage(color, gl_FragCoord.xy);
            fragColor = color;
        }}
        '''

        prog = None
        vao = None

        try:
            # 1. Create the Program for this specific sample.
            prog = self.ctx.program(
                vertex_shader=self.vert_shader,
                fragment_shader=full_frag_shader,
            )
            
            # Set the resolution uniforms for coordinate normalization.
            if 'iResolution' in prog:
                prog['iResolution'].value = (self.width, self.height)

            # 2. Create the Vertex Array Object.
            vao = self.ctx.simple_vertex_array(prog, self.vbo, 'in_vert')
            
            # 3. Perform the actual render.
            self.fbo.use()
            self.fbo.clear(0.0, 0.0, 0.0, 1.0)
            vao.render(moderngl.TRIANGLE_STRIP)
            
            # 4. Read the buffer and save the image.
            data = self.fbo.read(components=3)
            image = Image.frombytes('RGB', self.fbo.size, data)
            image = image.transpose(Image.FLIP_TOP_BOTTOM)
            image.save(output_path)
            
            return True

        except Exception as e:
            # Capture shader syntax errors generated by the model.
            return False
            
        finally:
            # Clean up the dynamic resources to prevent GPU memory leaks.
            if vao: vao.release()
            if prog: prog.release()

    def __del__(self):
        # Clean up the static resources when the renderer is destroyed.
        try:
            if hasattr(self, 'fbo') and self.fbo: self.fbo.release()
            if hasattr(self, 'vbo') and self.vbo: self.vbo.release()
            if hasattr(self, 'ctx') and self.ctx: self.ctx.release()
        except:
            pass